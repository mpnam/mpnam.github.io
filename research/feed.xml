<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Research</title>
    <description>&lt;h1&gt;Research&lt;/h1&gt;&lt;h3&gt;Some Notes on My Research!&lt;/h3&gt;Hope you like it!</description>
    <link>http://localhost:4000/research/</link>
    <atom:link href="http://localhost:4000/research/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 27 Jun 2017 00:56:09 +0900</pubDate>
    <lastBuildDate>Tue, 27 Jun 2017 00:56:09 +0900</lastBuildDate>
    <generator>Jekyll v3.5.0</generator>
    
      <item>
        <title>Theory of Equality</title>
        <description>&lt;p&gt;This post demonstrates the implementation of the satisfiability for the theory of equality where literals of the forms &lt;script type=&quot;math/tex&quot;&gt;X = Y&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;X \neq Y&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; are terms built from variables and applications for uninterpreted function symbols.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;preliminaries&quot;&gt;Preliminaries&lt;/h2&gt;
&lt;p&gt;The equivalence relation is given by following axioms:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Reflexivity:&lt;/strong&gt; &lt;script type=&quot;math/tex&quot;&gt;X = X&lt;/script&gt; &lt;br /&gt;
&lt;strong&gt;Symmetry:&lt;/strong&gt; &lt;script type=&quot;math/tex&quot;&gt;X = Y\Rightarrow Y = X&lt;/script&gt; &lt;br /&gt;
&lt;strong&gt;Transitivity:&lt;/strong&gt; &lt;script type=&quot;math/tex&quot;&gt;X = Y \wedge Y = Z\Rightarrow X = Z&lt;/script&gt; &lt;br /&gt;
&lt;strong&gt;Congruence:&lt;/strong&gt; For each &lt;script type=&quot;math/tex&quot;&gt;n-ary&lt;/script&gt; function &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;f(s_1,...,s_n)=f(t_1,...,t_n)&lt;/script&gt; if &lt;script type=&quot;math/tex&quot;&gt;s_i=t_i&lt;/script&gt; for each &lt;script type=&quot;math/tex&quot;&gt;1\leq i \leq n&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;I will use the notation &lt;script type=&quot;math/tex&quot;&gt;\pi(t)&lt;/script&gt; for the set of terms of the form &lt;script type=&quot;math/tex&quot;&gt;f(t_1,...t_n)&lt;/script&gt; such that for some &lt;script type=&quot;math/tex&quot;&gt;i, 1\leq i \leq n, t\equiv t_i&lt;/script&gt;. Other hands, &lt;script type=&quot;math/tex&quot;&gt;\pi(t)&lt;/script&gt; is the set of parents of the equivalence class rooted by &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;I will use the following example through out the post.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(a,b)=a,\ f(f(a,b),b)=c,\ g(a)\neq g(c)&lt;/script&gt;

&lt;h2 id=&quot;union-find-algorithm&quot;&gt;Union-find algorithm&lt;/h2&gt;
&lt;p&gt;This is the most basic algorithm for checking satisfiabilily. The algorithm maintains two main data structures: a mapping &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; on the variables in the input and a set of input disequalities &lt;script type=&quot;math/tex&quot;&gt;D&lt;/script&gt;. Besides, it also maintains set of &lt;script type=&quot;math/tex&quot;&gt;\pi(t)&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; is variables appearing in the input. For the example shown above,&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Initial:&lt;/strong&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;F=\{a\mapsto a, b\mapsto b, c\mapsto c,f(a,b)\mapsto f(a,b), f(f(a,b),b)\mapsto f(f(a,b),b), g(a)\mapsto g(a),g(c)\mapsto g(c) \}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;D=\{\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(a)=\{f(a,b),g(a)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(b)=\{f(a,b),f(f(a,b),b)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(c)=\{g(c)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(f(a,b))=\{f(f(a,b),b)\}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 1:&lt;/strong&gt; input &lt;script type=&quot;math/tex&quot;&gt;f(a,b)=a&lt;/script&gt;. After update &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt;, we check for each pair &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; of &lt;script type=&quot;math/tex&quot;&gt;\pi(f(a,b))&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\pi(a)&lt;/script&gt; if &lt;script type=&quot;math/tex&quot;&gt;q_1\equiv q_2&lt;/script&gt;. In this case, &lt;script type=&quot;math/tex&quot;&gt;f(f(a,b),b)\equiv f(a,b)&lt;/script&gt; . Therefore, we add this to the queue of equalities to be merged.
&lt;script type=&quot;math/tex&quot;&gt;F=\{a\mapsto a, b\mapsto b, c\mapsto c,f(a,b)\mapsto \color{red}{a}, f(f(a,b),b)\mapsto f(f(a,b),b), g(a)\mapsto g(a),g(c)\mapsto g(c) \}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;D=\{\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(a)=\{f(a,b),g(a)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(b)=\{f(a,b),f(f(a,b),b)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(c)=\{g(c)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(f(a,b))=\{f(f(a,b),b)\}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 2:&lt;/strong&gt; input &lt;script type=&quot;math/tex&quot;&gt;f(f(a,b),b)= f(a,b)&lt;/script&gt;. Note that, the root equivalence class of &lt;script type=&quot;math/tex&quot;&gt;f(a,b)&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;. Therefore, we update &lt;script type=&quot;math/tex&quot;&gt;f(f(a,b),b)&lt;/script&gt; to be &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;.
&lt;script type=&quot;math/tex&quot;&gt;F=\{a\mapsto a, b\mapsto b, c\mapsto c,f(a,b)\mapsto a, f(f(a,b),b)\mapsto \color{red}{a}, g(a)\mapsto g(a),g(c)\mapsto g(c) \}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;D=\{\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(a)=\{f(a,b),g(a)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(b)=\{f(a,b),f(f(a,b),b)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(c)=\{g(c)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(f(a,b))=\{f(f(a,b),b)\}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 3:&lt;/strong&gt; input &lt;script type=&quot;math/tex&quot;&gt;f(f(a,b),b)=c&lt;/script&gt;. For optimization, instead of update &lt;script type=&quot;math/tex&quot;&gt;a=c&lt;/script&gt; since &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is the root of equivalence class of  &lt;script type=&quot;math/tex&quot;&gt;f(f(a,b),b)&lt;/script&gt;, we update &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; to be &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;. Then, &lt;script type=&quot;math/tex&quot;&gt;g(a)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;g(c)&lt;/script&gt; becomes equivalence and thus add to the queue of equalities to be merged.
&lt;script type=&quot;math/tex&quot;&gt;F=\{a\mapsto a, b\mapsto b, c\mapsto \color{red}{a},f(a,b)\mapsto a, f(f(a,b),b)\mapsto a, g(a)\mapsto g(a),g(c)\mapsto g(c) \}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;D=\{\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(a)=\{f(a,b),g(a)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(b)=\{f(a,b),f(f(a,b),b)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(c)=\{g(c)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(f(a,b))=\{f(f(a,b),b)\}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 4:&lt;/strong&gt; input &lt;script type=&quot;math/tex&quot;&gt;g(a)=g(c)&lt;/script&gt;. &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;F=\{a\mapsto a, b\mapsto b, c\mapsto a,f(a,b)\mapsto a, f(f(a,b),b)\mapsto a, g(a)\mapsto g(a),g(c)\mapsto g(c), \color{red}{g(a)=g(c)} \}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;D=\{\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(a)=\{f(a,b),g(a),\color{red}{g(c)}\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(b)=\{f(a,b),f(f(a,b),b)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(c)=\{g(c)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(f(a,b))=\{f(f(a,b),b)\}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 5:&lt;/strong&gt; input &lt;script type=&quot;math/tex&quot;&gt;g(a)\neq g(c)&lt;/script&gt; =&amp;gt; conflict due to &lt;script type=&quot;math/tex&quot;&gt;\color{red}{g(a)=g(c)}&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt;. &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;F=\{a\mapsto a, b\mapsto b, c\mapsto a,f(a,b)\mapsto a, f(f(a,b),b)\mapsto a, g(a)\mapsto g(a),g(c)\mapsto g(c), \color{red}{g(a)=g(c)} \}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;D=\{\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(a)=\{f(a,b),g(a),g(c)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(b)=\{f(a,b),f(f(a,b),b)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(c)=\{g(c)\}&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\pi(f(a,b))=\{f(f(a,b),b)\}&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&quot;e-graph&quot;&gt;E-Graph&lt;/h2&gt;
&lt;p&gt;E-Graph is used in Simplify. It uses DAG (vertex-labeled directed oriented acyclic multigraph) to represent ground terms. In this context, ground terms are terms which do not have any quantifed variables. I will not describe in the detail E-Graph data structure in this post.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Initial:&lt;/strong&gt;  &lt;br /&gt;
&lt;img src=&quot;http://mpnam.github.io/img/research/e-graph1.png&quot; alt=&quot;&quot; style=&quot;margin:0 auto;width:30%;height:30%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 1:&lt;/strong&gt; input &lt;script type=&quot;math/tex&quot;&gt;f(a,b)=a&lt;/script&gt; &lt;br /&gt;
&lt;img src=&quot;http://mpnam.github.io/img/e-graph2.png&quot; alt=&quot;&quot; style=&quot;margin:0 auto;width:30%;height:30%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 2:&lt;/strong&gt; update equivalence relation
&lt;img src=&quot;http://mpnam.github.io/img/research/e-graph3.png&quot; alt=&quot;&quot; style=&quot;margin:0 auto;width:30%;height:30%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 3:&lt;/strong&gt; input &lt;script type=&quot;math/tex&quot;&gt;f(f(a,b),b)=c&lt;/script&gt; &lt;br /&gt;
&lt;img src=&quot;http://mpnam.github.io/img/research/e-graph4.png&quot; alt=&quot;&quot; style=&quot;margin:0 auto;width:30%;height:30%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 4:&lt;/strong&gt; update equivalence relation
&lt;img src=&quot;http://mpnam.github.io/img/research/e-graph5.png&quot; alt=&quot;&quot; style=&quot;margin:0 auto;width:30%;height:30%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Based on the graph above, since &lt;script type=&quot;math/tex&quot;&gt;g(a)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;g(b)&lt;/script&gt; are equivalence, the input &lt;script type=&quot;math/tex&quot;&gt;g(a)\neq g(c)&lt;/script&gt; makes the formula is unsatisfiable.&lt;/p&gt;
</description>
        <pubDate>Wed, 15 Mar 2017 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/research/logic/2017/03/15/theory-of-equality.html</link>
        <guid isPermaLink="true">http://localhost:4000/research/logic/2017/03/15/theory-of-equality.html</guid>
        
        
        <category>Logic</category>
        
      </item>
    
      <item>
        <title>DPLL Algorithm</title>
        <description>&lt;p&gt;This post is assumed that the readers have background in logic. DPLL (Davis-Putnam-Logemann-Loveland) is the basic algorithm for SAT solving.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;examples&quot;&gt;Examples&lt;/h2&gt;
&lt;p&gt;The easiest way to learn an algorithm is from example. SAT problem is checking if a boolean formula is satisfiable. Because the first step of DPLL is to convert the formula into conjunctive normal form (CNF), I will use CNF form for any formula from now. Consider the following formula &lt;script type=&quot;math/tex&quot;&gt;K\equiv(p \vee q)\wedge (\neg p \vee q)\wedge (p\vee \neg q)\wedge (s\vee \neg p\vee q)\wedge (\neg s\vee p \vee \neg q)&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;K&lt;/script&gt; is satisfiable if there exists a model &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;M\models K&lt;/script&gt;. In this example, &lt;script type=&quot;math/tex&quot;&gt;K&lt;/script&gt; is satisfiable with model &lt;script type=&quot;math/tex&quot;&gt;\{p\mapsto \top, q\mapsto \top\,s\mapsto \top\}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Intuitively, to satisfy &lt;script type=&quot;math/tex&quot;&gt;K&lt;/script&gt;, we need to find assignments such that satisfy &lt;script type=&quot;math/tex&quot;&gt;(p \vee q), (\neg p \vee q), (p\vee \neg q), (s\vee \neg p\vee q)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;(\neg s\vee p \vee \neg q)&lt;/script&gt;. Firstly, we randomly assign &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\top&lt;/script&gt;. With this assumption, we obviously see that &lt;script type=&quot;math/tex&quot;&gt;(p \vee q), (p\vee \neg q)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;(\neg s\vee p \vee \neg q)&lt;/script&gt; are satisfied. In order to satisfy &lt;script type=&quot;math/tex&quot;&gt;(\neg p \vee q)&lt;/script&gt;, we need to assign &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\top&lt;/script&gt;. With this new assumption, we obviously see that &lt;script type=&quot;math/tex&quot;&gt;(s\vee \neg p\vee q)&lt;/script&gt; is satisfied. Finally, we have already satisfy all formulas by assignments &lt;script type=&quot;math/tex&quot;&gt;\{p\mapsto \top, q\mapsto \top\}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Assume that in the first step, we randomly assign &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\bot&lt;/script&gt;. With this assumption, we obviously see that &lt;script type=&quot;math/tex&quot;&gt;(\neg p \vee q)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;(s\vee \neg p\vee q)&lt;/script&gt; are satisfied. In order to satisfy &lt;script type=&quot;math/tex&quot;&gt;(p\vee \neg q)&lt;/script&gt;, we need to assign &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\bot&lt;/script&gt;. However, we see that with the current assumptions, &lt;script type=&quot;math/tex&quot;&gt;(p \vee q)&lt;/script&gt; is unsatisfiable. So we backjump to the previous assignment and assign &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\top&lt;/script&gt;. However, the new assumptions makes &lt;script type=&quot;math/tex&quot;&gt;(p \vee q)&lt;/script&gt; is unsatisfiable. Therefore, we backjump to the assignment of &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;. And go on,…&lt;/p&gt;

&lt;h2 id=&quot;abstract-dpll&quot;&gt;Abstract DPLL&lt;/h2&gt;
&lt;p&gt;Before simulating how DPLL works over the example shown above. I would like to use the abstract version of DPLL which represented in Leonardo de Moura’s slides, &lt;em&gt;Summer School on Logic and Theorem Proving&lt;/em&gt;
&lt;img src=&quot;https://mpnam.github.io/img/research/dpll.png&quot; alt=&quot;Summer School on Logic and Theorem Proving - Leonardo de Moura&quot; style=&quot;margin:0 auto;width:60%;height:60%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Each state of the procedure is a 3-tuple &lt;script type=&quot;math/tex&quot;&gt;\langle M,F,C \rangle&lt;/script&gt; consisting of partial assignment &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;, the input clause set &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; and a set &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; of conflict clauses derived from &lt;script type=&quot;math/tex&quot;&gt;K&lt;/script&gt;. I will give an intuitive explanation of each rule:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(Decide):&lt;/strong&gt; select an literal in &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; which has not been assigned yet, then assign it in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;. It is similar to ramdomly assignment in the example.&lt;br /&gt;
&lt;strong&gt;(UnitPropagate):&lt;/strong&gt; with the current assignment &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;, we are looking for some formula in &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; only satisfies this formula if &lt;script type=&quot;math/tex&quot;&gt;l&lt;/script&gt; is assigned. It looks like in Sudoku game. You may have some assumptions over some places. The other values over other places are filled based on those assumptions. &lt;br /&gt;
&lt;strong&gt;(Conflict):&lt;/strong&gt; The current $M$ leads to conflict state where there is exists clauses such that they are unsatisfiable. &lt;br /&gt;
&lt;strong&gt;(Resolve):&lt;/strong&gt;  Intuitively, if there is a model satisfies &lt;script type=&quot;math/tex&quot;&gt;(C \vee \neg l) \wedge (D \vee l)&lt;/script&gt;, this model also satisfies &lt;script type=&quot;math/tex&quot;&gt;C\vee D&lt;/script&gt;. &lt;br /&gt;
&lt;strong&gt;(Learn):&lt;/strong&gt; We may imply new formulas after resolving step. Learn simply update new formulas into input set. &lt;br /&gt;
&lt;strong&gt;(Backjump):&lt;/strong&gt; Backjump to the point where we can satisfy &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; by new decide. &lt;br /&gt;
&lt;strong&gt;(Unsat):&lt;/strong&gt; Obviously, if we unable to find an assignment to resolve conflict, it is unsatisfiable.&lt;/p&gt;

&lt;h2 id=&quot;examples-using-dpll&quot;&gt;Examples using DPLL&lt;/h2&gt;
&lt;p&gt;Consider the following example:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\emptyset \ ||\ (p \vee q)\wedge (\neg p \vee q)\wedge (p\vee \neg q)\wedge (s\vee \neg p\vee q)\wedge (\neg s\vee p \vee \neg q) \Rightarrow \textbf{(Decide)}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg p \ ||\ (p \vee q)\wedge (\neg p \vee q)\wedge (p\vee \neg q)\wedge (s\vee \neg p\vee q)\wedge (\neg s\vee p \vee \neg q) \Rightarrow \textbf{(UnitPropagate)}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg p, q[p \vee q] \ ||\ (p \vee q)\wedge (\neg p \vee q)\wedge (p\vee \neg q)\wedge (s\vee \neg p\vee q)\wedge (\neg s\vee p \vee \neg q) \Rightarrow \textbf{(Conflict)}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg p, q[p \vee q] \ ||\ (p \vee q)\wedge (\neg p \vee q)\wedge (p\vee \neg q)\wedge (s\vee \neg p\vee q)\wedge (\neg s\vee p \vee \neg q) \ ||\ (p\vee \neg q) \Rightarrow \textbf{(Resolve)}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg p, q[p \vee q] \ ||\ (p \vee q)\wedge (\neg p \vee q)\wedge (p\vee \neg q)\wedge (s\vee \neg p\vee q)\wedge (\neg s\vee p \vee \neg q) \ ||\ p \Rightarrow \textbf{(Learn)}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg p, q[p \vee q] \ ||\ (p \vee q)\wedge (\neg p \vee q)\wedge (p\vee \neg q)\wedge (s\vee \neg p\vee q)\wedge (\neg s\vee p \vee \neg q)\wedge p \ ||\ p \Rightarrow \textbf{(Backjump)}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \ ||\ (p \vee q)\wedge (\neg p \vee q)\wedge (p\vee \neg q)\wedge (s\vee \neg p\vee q)\wedge (\neg s\vee p \vee \neg q)\wedge p \Rightarrow \textbf{(UnitPropagate)}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p, q[\neg p \vee q] \ ||\ (p \vee q)\wedge (\neg p \vee q)\wedge (p\vee \neg q)\wedge (s\vee \neg p\vee q)\wedge (\neg s\vee p \vee \neg q)\wedge p&lt;/script&gt;

&lt;p&gt;The algorithm stops when &lt;script type=&quot;math/tex&quot;&gt;M\models F&lt;/script&gt;. In this case is &lt;script type=&quot;math/tex&quot;&gt;p,q&lt;/script&gt;.&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Mar 2017 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/research/logic/2017/03/14/dpll-algorithm.html</link>
        <guid isPermaLink="true">http://localhost:4000/research/logic/2017/03/14/dpll-algorithm.html</guid>
        
        
        <category>Logic</category>
        
      </item>
    
  </channel>
</rss>
